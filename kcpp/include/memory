// vim: set filetype=cpp:

#pragma once

#include <atomic>
#include <utility>

namespace {
template <typename T> class RefList;
template <typename T> class RefListIterator;
}

namespace std {

template <typename T>
T latch(T& var, T value = T()) {
    std::swap(value, var);
    return value;
}
template <typename T>
T* latch(T*& var, nullptr_t) {
    T* res = var;
    var = nullptr;
    return res;
}

template <typename T>
struct default_delete
{
    void operator()(T* ptr) {
        delete ptr;
    }
};
template <typename T>
struct default_delete<T[]>
{
    void operator()(T* ptr) {
        delete[] ptr;
    }
};

// Split up into a control block struct without T, use pointer magic to get
// the other pointer (e.g. point to T, put control block just before that)
template <typename T>
struct __shared_ptr_impl {
    atomic<int32_t> count;
    __shared_ptr_impl *prev;
    __shared_ptr_impl *next;
    // 20 bytes above, might lose alignment
    T elem;

    template <typename... Args>
    __shared_ptr_impl(Args&&... args): elem(std::forward<Args>(args)...) {
    }

    __forceinline void addref() {
        count++;
    }
    template <class Deleter>
    __forceinline static void deref(__shared_ptr_impl*& ptr, Deleter&& deleter) {
        if (ptr) {
            auto p = latch(ptr, nullptr);
            if (!--p->count) {
                deleter(p);
            }
        }
    }

    T* get() {
        return &elem;
    }
};

// Should be as similar as possible to std::shared_ptr, but it's not intended
// to support separate object and refcount storage at this point. This means
// construction by raw pointer is not possible, make_shared *must* be used and
// it's not possible to use custom deleters.
//
// Thread safety notes (according to my understanding): a single shared_ptr
// is not thread safe - accesses must be synchronized externally. But multiple
// shared_ptr objects pointing to the same object will be safe to manipulate
// in different threads. Only a single thread will destroy the object, and it
// will do that after the point that no other thread may have any references to
// it (barring raw pointers escaping while the underlying shared_ptr is lost).
template <typename T>
class shared_ptr
{
    using __impl = __shared_ptr_impl<T>;
    __impl* __ptr = nullptr;

    void __addref() {
        __ptr->addref();
    }
    void __deref() {
        __impl::deref(__ptr, default_delete<__impl>());
    }

    friend class RefList<T>;
    friend class RefListIterator<T>;

public:
    shared_ptr() = default;
    shared_ptr(nullptr_t) {}

    shared_ptr(shared_ptr&& other): __ptr(other.__ptr) { other.__ptr = nullptr; }
    shared_ptr(const shared_ptr& other): shared_ptr(other.__ptr) {}

    explicit shared_ptr(__impl* ptr): __ptr(ptr) { if (ptr) __addref(); }

    ~shared_ptr() {
        __deref();
        __ptr = (__impl*)0xdeadbeef;
    }

    shared_ptr& operator=(shared_ptr&& other) {
        swap(__ptr, other.__ptr);
        other.reset();
        return *this;
    }
    shared_ptr& operator=(const shared_ptr& other) {
        __deref();
        if (other.__ptr) {
            __ptr = other.__ptr;
            __addref();
        }
        return *this;
    }

    void reset() {
        __deref();
    }

    T& operator*() const {
        return *get();
    }
    T* operator->() const {
        return get();
    }

    operator bool() const {
        return __ptr != nullptr;
    }
    bool operator==(const shared_ptr& other) const {
        return get() == other.get();
    }
    // FIXME comparison with raw pointer is not available in actual shared_ptr
    bool operator==(T *ptr) const {
        return get() == ptr;
    }
    bool operator!=(T *ptr) const {
        return get() != ptr;
    }
    bool operator==(nullptr_t) const {
        return __ptr == nullptr;
    }
    T* get() const {
        return __ptr ? __ptr->get() : nullptr;
    }

    size_t use_count() const {
        return __ptr ? __ptr->count.load() : 0;
    }
};

template <typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args)
{
    using __impl = __shared_ptr_impl<T>;
    return shared_ptr<T>(new __impl(std::forward<Args>(args)...));
}

template <typename T, typename Deleter = default_delete<T>>
class unique_ptr
{
    T* __ptr = nullptr;

public:
    constexpr unique_ptr() = default;
    constexpr unique_ptr(nullptr_t) {}
    explicit unique_ptr(T* ptr): __ptr(ptr) {}

    unique_ptr(const unique_ptr& ptr) = delete;
    unique_ptr(unique_ptr&& ptr): __ptr(ptr.release()) {}

    unique_ptr& operator=(const unique_ptr& ptr) = delete;
    unique_ptr& operator=(unique_ptr&& ptr) {
        reset(ptr.release());
    }

    void reset(T* ptr = nullptr) {
        Deleter()(__ptr);
        __ptr = ptr;
    }
    T* release() {
        T* res = __ptr;
        __ptr = nullptr;
        return res;
    }

    T& operator*() const {
        return *get();
    }
    T* operator->() const {
        return get();
    }
    T* get() const {
        return __ptr ? __ptr->get() : nullptr;
    }
};

template <typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args)
{
    return unique_ptr<T>(new T(std::forward<Args>(args)...));
}

}
